module std::Option;

public enum Option<T> {
    Some: T;
    None;

    public fun is_some(const this) -> bool {
        return match this {
            .Some => true,
            .None => false,
        };
    }

    public fun is_none(const this) -> bool {
        return !this.is_ok();
    }

    public fun unwrap(const this) -> T {
        return match this {
            .Some(x) => x,
            .None => panic("unwrap called on Option in None state")
        };
    }

    public fun unwrap_or(const this, const default: T) -> i32 {
        return match this {
            .Some(x) => x,
            .None => default,
        };
    }
}

public fun Some<T>(const value: T) -> Option<T> {
    return Option<T> { Some: value };
}

public fun None<T>() -> Option<T> {
    return Option<T> { None };
}

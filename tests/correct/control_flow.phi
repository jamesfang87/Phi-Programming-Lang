fun println(const msg: string) {}

// Test basic return statement
fun test_return() -> i64 {
    return 42;
}

// Test return with defer
fun test_return_with_defer() -> i64 {
    defer println("defer executed in return function");
    return 100;
}

// Test multiple defers (should execute in reverse order)
fun test_multiple_defers() {
    defer println("defer 1");
    defer println("defer 2");
    defer println("defer 3");
    // Should print: defer 3, defer 2, defer 1
}

// Test defer without explicit return (function exit)
fun test_defer_function_exit() {
    defer println("defer on function exit");
    const x = 5;
}

// Test break in while loop
fun test_while_break() {
    var i = 0;
    while (i < 10) {
        if (i == 5) {
            break;
        }
        println("while iteration");
        i = i + 1;
    }
    println("after while loop");
}

// Test continue in while loop
fun test_while_continue() {
    var i = 0;
    while (i < 5) {
        i = i + 1;
        if (i == 3) {
            continue;
        }
        println("while continue test");
    }
}

// Test break in for loop
fun test_for_break() {
    for i in 0..10 {
        if (i == 5) {
            break;
        }
        println("for iteration");
    }
    println("after for loop");
}

// Test continue in for loop
fun test_for_continue() {
    for i in 0..5 {
        if (i == 2) {
            continue;
        }
        println("for continue test");
    }
}

// Test nested loops with break/continue
fun test_nested_loops() {
    for i in 0..3 {
        for j in 0..3 {
            if (j == 1) {
                continue; // should continue inner loop
            }
            if (i == 2) {
                break; // should break inner loop
            }
            println("nested loop iteration");
        }
    }
}

// Test defer with early return
fun test_defer_early_return() -> i64 {
    defer println("defer with early return");

    const condition = true;
    if (condition) {
        return 25; // defer should still execute
    }

    return 50;
}

// Test complex control flow with all statements
fun test_complex_control_flow() -> i64 {
    defer println("function exit defer");

    var result = 0;
    for i in 0..5 {
        defer println("loop iteration defer");

        if (i == 1) {
            continue;
        }

        if (i == 4) {
            break;
        }

        var j = 0;
        while (j < 3) {
            if (j == 2) {
                break;
            }
            j = j + 1;
            result = result + 1;
        }
    }

    if (result > 5) {
        defer println("early return defer");
        return result;
    }

    return result * 2;
}

fun main() {
    println("Testing control flow statements");

    // Test returns
    const ret_val = test_return();
    const ret_defer_val = test_return_with_defer();

    // Test defers
    test_multiple_defers();
    test_defer_function_exit();

    // Test break/continue in loops
    test_while_break();
    test_while_continue();
    test_for_break();
    test_for_continue();
    test_nested_loops();

    // Test complex scenarios
    const early_ret = test_defer_early_return();
    const complex_result = test_complex_control_flow();

    println("All control flow tests completed");
}

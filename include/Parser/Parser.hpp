#pragma once

#include <memory>
#include <optional>
#include <string>
#include <string_view>
#include <utility>
#include <vector>

#include "AST/Decl.hpp"
#include "AST/Expr.hpp"
#include "AST/Stmt.hpp"
#include "AST/Type.hpp"
#include "Diagnostics/Diagnostic.hpp"
#include "Diagnostics/DiagnosticBuilder.hpp"
#include "Diagnostics/DiagnosticManager.hpp"
#include "Lexer/Token.hpp"
#include "Lexer/TokenType.hpp"

namespace phi {

/**
 * @brief Recursive descent parser for the Phi programming language
 *
 * Converts a sequence of tokens into an abstract syntax tree (AST) by
 * implementing grammar production rules through recursive methods. Features:
 * - Comprehensive error reporting with precise location information
 * - Robust error recovery through token synchronization points
 * - Pratt parsing for expression precedence handling
 * - Detailed context-aware error messages
 */
class Parser {
public:
  /**
   * @brief Constructs a parser instance
   *
   * @param src The complete source code being parsed
   * @param path The file path of the source code
   * @param tokens The token sequence generated by the lexer
   * @param diagnostic_manager The diagnostic reporting system
   */
  Parser(const std::string_view src, const std::string_view path,
         std::vector<Token> &tokens,
         std::shared_ptr<DiagnosticManager> diagnosticManager);

  /**
   * @brief Main entry point for parsing
   *
   * @return std::pair<std::vector<std::unique_ptr<FunDecl>>, bool>
   *         First element: Vector of parsed function declarations
   *         Second element: true if parsing completed without errors,
   *                        false if errors occurred
   */
  std::pair<std::vector<std::unique_ptr<FunDecl>>, bool> parse();

private:
  // PARSER STATE
  std::string path;
  std::vector<std::string_view> lines;
  std::vector<Token> &tokens;
  std::vector<Token>::iterator tokenIt;
  std::vector<std::unique_ptr<FunDecl>> functions;
  std::shared_ptr<DiagnosticManager> diagnosticManager;

  // TOKEN NAVIGATION UTILITIES
  /// Checks if parser has reached end of token stream
  [[nodiscard]] bool atEOF() const;

  /// Returns the current token without advancing
  [[nodiscard]] Token peekToken() const;

  /// Advances to next token and returns the previous one
  Token advanceToken();

  /**
   * @brief Verifies current token matches expected type
   *
   * @param expected_type The expected token type
   * @param context Context description for error messages
   * @return true if token matches, false otherwise
   *
   * @note Automatically generates error if token doesn't match
   */
  bool expectToken(TokenKind expected_type, const std::string &context = "");

  /**
   * @brief Conditionally consumes token if it matches
   *
   * @param type Token type to match
   * @return true if token matched and consumed, false otherwise
   */
  bool matchToken(TokenKind type);

  // DIAGNOSTIC REPORTING
  void emitError(Diagnostic &&diagnostic) {
    diagnosticManager->emit(diagnostic);
  }
  void emitWarning(Diagnostic &&diagnostic) const {
    diagnosticManager->emit(diagnostic);
  }

  /**
   * @brief Reports "expected X but found Y" error
   *
   * @param expected String description of expected token
   * @param found_token The actual token encountered
   */
  void emitExpectedFoundError(const std::string &expected,
                              const Token &found_token);

  /**
   * @brief Reports unexpected token error
   *
   * @param token The unexpected token
   * @param expected_tokens List of expected token descriptions
   */
  void emitUnexpectedTokenError(
      const Token &token, const std::vector<std::string> &expected_tokens = {});

  /**
   * @brief Reports unclosed delimiter error
   *
   * @param opening_token The opening delimiter token
   * @param expected_closing String representation of expected closing delimiter
   */
  void emitUnclosedDelimiterError(const Token &opening_token,
                                  const std::string &expected_closing);

  // ERROR RECOVERY
  /**
   * @brief Synchronizes parser state to next safe point
   *
   * Attempts to recover from errors by skipping tokens until reaching a
   * token that likely begins a new construct (statement or declaration).
   *
   * @return true if synchronized successfully, false if reached EOF
   */
  bool SyncToTopLvl();

  /**
   * @brief Synchronizes parser state to next safe point
   *
   * Attempts to recover from errors by skipping tokens until reaching a
   * token that likely begins a new construct (statement or declaration).
   *
   * @return true if synchronized successfully, false if reached EOF
   */
  bool SyncToStmt();

  /**
   * @brief Synchronizes to one of specified token types
   *
   * @param target_tokens Set of tokens to synchronize to
   * @return true if found synchronization token, false if reached EOF
   */
  bool syncTo(const std::initializer_list<TokenKind> target_tokens);

  /**
   * @brief Synchronizes to specific token type
   *
   * @param target_token Token type to synchronize to
   * @return true if found target token, false if reached EOF
   */
  bool syncTo(const TokenKind target_token);

  // TYPE SYSTEM PARSING
  /**
   * @brief Parses type annotations
   *
   * @return std::optional<Type>
   *         Valid type if successful, std::nullopt on failure
   *         Errors are reported through the DiagnosticManager
   */
  std::optional<Type> parseType();

  // FUNCTION DECLARATION PARSING
  std::unique_ptr<FunDecl> parseFunDecl();
  std::unique_ptr<ParamDecl> parseParamDecl();
  std::unique_ptr<Block> parseBlock();

  // STATEMENT PARSING
  std::unique_ptr<Stmt> parseStmt();
  std::unique_ptr<ReturnStmt> parseReturn();
  std::unique_ptr<IfStmt> parseIf();
  std::unique_ptr<WhileStmt> parseWhile();
  std::unique_ptr<ForStmt> parseFor();
  std::unique_ptr<LetStmt> parseLet();

  // EXPRESSION PARSING
  std::unique_ptr<Expr> parseExpr();

  /**
   * @brief Pratt parser implementation for expressions
   *
   * @param min_bp Minimum binding power for current context
   * @return std::unique_ptr<Expr>
   *         Parsed expression or nullptr on failure
   *         Errors are emitted to DiagnosticManager
   */
  std::unique_ptr<Expr> pratt(int min_bp);

  std::unique_ptr<Expr> parsePrefix(const Token &tok);

  /**
   * @brief Parses postfix operators for an expression
   *
   * @param expr The expression to apply postfix operators to
   * @return std::unique_ptr<Expr>
   *         Expression with postfix operators applied or nullptr on failure
   *         Errors are emitted to DiagnosticManager
   */
  std::unique_ptr<Expr> parsePostfix(std::unique_ptr<Expr> expr);

  /**
   * @brief Parses function call expressions
   *
   * @param callee The expression being called
   * @return std::unique_ptr<FunCallExpr>
   *         Function call expression or nullptr on failure
   *         Errors are emitted to DiagnosticManager
   */
  std::unique_ptr<FunCallExpr> parseFunCall(std::unique_ptr<Expr> callee);

  // PARSING UTILITIES
  struct TypedBinding {
    SrcLocation loc;
    std::string name;
    Type type;
  };
  std::optional<TypedBinding> parseTypedBinding();

  /**
   * @brief Generic list parsing template
   *
   * Parses comma-separated lists enclosed by delimiters (e.g., parameters,
   * arguments)
   *
   * @tparam T Type of elements in the list
   * @tparam F Parser method type for individual elements
   * @param opening Opening delimiter token type
   * @param closing Closing delimiter token type
   * @param fun Member function pointer to element parser
   * @param context Description of list context for error messages
   * @return std::vector<std::unique_ptr<T>>
   *         Vector of parsed elements (empty on failure)
   *         Errors are emitted to DiagnosticManager
   */
  template <typename T, typename F>
  std::optional<std::vector<std::unique_ptr<T>>>
  parseList(const TokenKind opening, const TokenKind closing, F fun,
            const std::string &context = "list") {
    // Verify opening delimiter
    const Token opening_token = peekToken();
    if (opening_token.getTy() != opening) {
      emitExpectedFoundError(tyToStr(opening), peekToken());
      return std::nullopt;
    }
    advanceToken();

    // Parse list elements
    std::vector<std::unique_ptr<T>> content;
    while (!atEOF() && peekToken().getTy() != closing) {
      auto result = (this->*fun)();
      if (!result) {
        // Recover by syncing to comma or closing delimiter
        syncTo({closing, TokenKind::tokComma});
        continue;
      }
      content.push_back(std::move(result));

      // Check for closing delimiter before comma
      if (peekToken().getTy() == closing) {
        break;
      }

      // Handle comma separator
      if (peekToken().getTy() == TokenKind::tokComma) {
        advanceToken();
      } else {
        emitError(
            error("missing comma in " + context)
                .with_primary_label(spanFromToken(peekToken()),
                                    "expected `,` here")
                .with_help("separate " + context + " elements with commas")
                .build());
        return std::nullopt;
      }
    }

    // Verify closing delimiter
    if (atEOF() || peekToken().getTy() != closing) {
      emitUnclosedDelimiterError(opening_token, tyToStr(closing));
      return std::nullopt;
    }

    advanceToken(); // Consume closing delimiter
    return content;
  }
};

} // namespace phi

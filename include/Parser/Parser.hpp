#pragma once

#include <initializer_list>
#include <memory>
#include <optional>
#include <string>
#include <string_view>
#include <utility>
#include <vector>

#include "AST/Decl.hpp"
#include "AST/Expr.hpp"
#include "AST/Stmt.hpp"
#include "AST/Type.hpp"
#include "Diagnostics/Diagnostic.hpp"
#include "Diagnostics/DiagnosticBuilder.hpp"
#include "Diagnostics/DiagnosticManager.hpp"
#include "Lexer/Token.hpp"
#include "Lexer/TokenKind.hpp"

namespace phi {

/**
 * @brief Recursive descent parser for the Phi programming language
 *
 * Converts a sequence of tokens into an abstract syntax tree (AST) by
 * implementing grammar production rules through recursive methods. Features:
 * - Comprehensive error reporting with precise location information
 * - Robust error recovery through token synchronization points
 * - Pratt parsing for expression precedence handling
 * - Detailed context-aware error messages
 */
class Parser {
public:
  /**
   * @brief Constructs a parser instance
   *
   * @param src The complete source code being parsed
   * @param path The file path of the source code
   * @param tokens The token sequence generated by the lexer
   * @param diagnostic_manager The diagnostic reporting system
   */
  Parser(const std::string_view Src, const std::string_view Path,
         std::vector<Token> &Tokens,
         std::shared_ptr<DiagnosticManager> DiagnosticManager);

  /**
   * @brief Main entry point for parsing
   *
   * @return std::pair<std::vector<std::unique_ptr<FunDecl>>, bool>
   *         First element: Vector of parsed function declarations
   *         Second element: true if parsing completed without errors,
   *                        false if errors occurred
   */
  std::vector<std::unique_ptr<Decl>> parse();

private:
  // PARSER STATE
  std::string Path;
  std::vector<std::string_view> Lines;
  std::vector<Token> &Tokens;
  std::vector<Token>::iterator TokenIt;
  std::vector<std::unique_ptr<Decl>> TopLvlDecls;
  std::shared_ptr<DiagnosticManager> DiagnosticsMan;

  bool NoStructInit = false;

  // TOKEN NAVIGATION UTILITIES
  /// Checks if parser has reached end of token stream
  [[nodiscard]] bool atEOF() const;

  /// Returns the current token without advancing
  [[nodiscard]] Token peekToken() const;

  [[nodiscard]] Token peekToken(int Offset) const {
    const SrcLocation EofLoc{.path = "", .line = -1, .col = -1};
    auto It = TokenIt + Offset;
    if (It >= Tokens.end())
      return Token{EofLoc, EofLoc, TokenKind::Eof, ""};
    return *It;
  }

  /// Advances to next token and returns the previous one
  Token advanceToken();

  /**
   * @brief Verifies current token matches expected type
   *
   * @param expected_type The expected token type
   * @param context Context description for error messages
   * @return true if token matches, false otherwise
   *
   * @note Automatically generates error if token doesn't match
   */
  bool expectToken(TokenKind Expected, const std::string &Context = "");

  /**
   * @brief Conditionally consumes token if it matches
   *
   * @param type Token type to match
   * @return true if token matched and consumed, false otherwise
   */
  bool matchToken(TokenKind Kind);

  // DIAGNOSTIC REPORTING
  void emitError(Diagnostic &&Diag) { DiagnosticsMan->emit(Diag); }
  void emitWarning(Diagnostic &&Diag) const { DiagnosticsMan->emit(Diag); }

  /**
   * @brief Reports "expected X but found Y" error
   *
   * @param expected String description of expected token
   * @param found_token The actual token encountered
   */
  void emitExpectedFoundError(const std::string &Expected,
                              const Token &FoundToken);

  /**
   * @brief Reports unexpected token error
   *
   * @param token The unexpected token
   * @param expected_tokens List of expected token descriptions
   */
  void
  emitUnexpectedTokenError(const Token &Token,
                           const std::vector<std::string> &ExpectedTokens = {});

  /**
   * @brief Reports unclosed delimiter error
   *
   * @param opening_token The opening delimiter token
   * @param expected_closing String representation of expected closing delimiter
   */
  void emitUnclosedDelimiterError(const Token &OpeningToken,
                                  const std::string &ExpectedClosing);

  // ERROR RECOVERY
  /**
   * @brief Synchronizes parser state to next safe point
   *
   * Attempts to recover from errors by skipping tokens until reaching a
   * token that likely begins a new construct (statement or declaration).
   *
   * @return true if synchronized successfully, false if reached EOF
   */
  bool SyncToTopLvl();

  /**
   * @brief Synchronizes parser state to next safe point
   *
   * Attempts to recover from errors by skipping tokens until reaching a
   * token that likely begins a new construct (statement or declaration).
   *
   * @return true if synchronized successfully, false if reached EOF
   */
  bool SyncToStmt();

  /**
   * @brief Synchronizes to one of specified token types
   *
   * @param target_tokens Set of tokens to synchronize to
   * @return true if found synchronization token, false if reached EOF
   */
  bool syncTo(const std::initializer_list<TokenKind> TargetTokens);

  /**
   * @brief Synchronizes to specific token type
   *
   * @param target_token Token type to synchronize to
   * @return true if found target token, false if reached EOF
   */
  bool syncTo(const TokenKind TargetToken);

  // TYPE SYSTEM PARSING
  /**
   * @brief Parses type annotations
   *
   * @return std::optional<Type>
   *         Valid type if successful, std::nullopt on failure
   *         Errors are reported through the DiagnosticManager
   */
  std::optional<Type> parseType();

  /**
   * @brief Parses struct declaration
   *
   * @return std::unique_ptr<StructDecl>
   *         Valid struct declaration if successful, nullptr on failure
   *         Errors are reported through the DiagnosticManager
   */
  std::unique_ptr<StructDecl> parseStructDecl();
  std::optional<FieldDecl> parseFieldDecl();
  std::optional<MethodDecl> parseStructMethodDecl();

  // FUNCTION DECLARATION PARSING
  std::unique_ptr<FunDecl> parseFunDecl();
  std::unique_ptr<ParamDecl> parseParamDecl();
  std::unique_ptr<Block> parseBlock();

  // STATEMENT PARSING
  std::unique_ptr<Stmt> parseStmt();
  std::unique_ptr<ReturnStmt> parseReturn();
  std::unique_ptr<DeferStmt> parseDefer();
  std::unique_ptr<IfStmt> parseIf();
  std::unique_ptr<WhileStmt> parseWhile();
  std::unique_ptr<ForStmt> parseFor();
  std::unique_ptr<DeclStmt> parseDecl();
  std::unique_ptr<BreakStmt> parseBreak();
  std::unique_ptr<ContinueStmt> parseContinue();

  // EXPRESSION PARSING
  std::unique_ptr<Expr> parseExpr();

  std::unique_ptr<StructInitExpr> parseStructInit(std::unique_ptr<Expr> expr);
  std::unique_ptr<FieldInitExpr> parseFieldInit();

  /**
   * @brief Pratt parser implementation for expressions
   *
   * @param min_bp Minimum binding power for current context
   * @return std::unique_ptr<Expr>
   *         Parsed expression or nullptr on failure
   *         Errors are emitted to DiagnosticManager
   */
  std::unique_ptr<Expr> pratt(int MinBp,
                              const std::vector<TokenKind> &Terminators);

  std::unique_ptr<Expr> parseNud(const Token &Tok);
  std::unique_ptr<Expr> parsePrefixUnaryOp(const Token &Tok);
  std::unique_ptr<Expr> parseLiteralExpr(const Token &Tok);
  std::unique_ptr<Expr> parseGroupingExpr();

  std::unique_ptr<Expr> parsePostfix(const Token &Op,
                                     std::unique_ptr<Expr> Expr);
  std::unique_ptr<Expr> parseInfix(const Token &Op, std::unique_ptr<Expr> Expr,
                                   int RBp);

  /**
   * @brief Parses function call expressions
   *
   * @param callee The expression being called
   * @return std::unique_ptr<FunCallExpr>
   *         Function call expression or nullptr on failure
   *         Errors are emitted to DiagnosticManager
   */
  std::unique_ptr<FunCallExpr> parseFunCall(std::unique_ptr<Expr> Callee);

  // PARSING UTILITIES
  struct TypedBinding {
    SrcLocation Loc;
    std::string Name;
    Type Type;
  };
  std::optional<TypedBinding> parseTypedBinding();

  /**
   * @brief Generic list parsing template
   *
   * Parses comma-separated lists enclosed by delimiters (e.g., parameters,
   * arguments)
   *
   * @tparam T Type of elements in the list
   * @tparam F Parser method type for individual elements
   * @param opening Opening delimiter token type
   * @param closing Closing delimiter token type
   * @param fun Member function pointer to element parser
   * @param context Description of list context for error messages
   * @return std::vector<std::unique_ptr<T>>
   *         Vector of parsed elements (empty on failure)
   *         Errors are emitted to DiagnosticManager
   */
  template <typename T, typename F>
  std::optional<std::vector<std::unique_ptr<T>>>
  parseList(const TokenKind Opening, const TokenKind Closing, F Fun,
            const std::string &Context = "list") {
    // Verify opening delimiter
    const Token OpeningToken = peekToken();
    if (OpeningToken.getKind() != Opening) {
      emitExpectedFoundError(tyToStr(Opening), OpeningToken);
      return std::nullopt;
    }
    advanceToken();

    // Parse list elements
    std::vector<std::unique_ptr<T>> content;
    while (!atEOF() && peekToken().getKind() != Closing) {
      auto result = (this->*Fun)();
      if (result) {
        content.push_back(std::move(result));
      } else {
        // Recover by syncing to comma or closing delimiter
        syncTo({Closing, TokenKind::Comma});
      }

      // Check for closing delimiter before comma
      if (peekToken().getKind() == Closing) {
        break;
      }

      // Handle comma separator
      if (peekToken().getKind() == TokenKind::Comma) {
        advanceToken();
      } else {
        emitError(
            error("missing comma in " + Context)
                .with_primary_label(spanFromToken(peekToken()),
                                    "expected `,` here")
                .with_help("separate " + Context + " elements with commas")
                .build());
        return std::nullopt;
      }
    }

    // Verify closing delimiter
    if (atEOF() || peekToken().getKind() != Closing) {
      emitUnclosedDelimiterError(OpeningToken, tyToStr(Closing));
      return std::nullopt;
    }

    advanceToken(); // Consume closing delimiter
    return content;
  }
};

} // namespace phi

#pragma once

#include <cstdint>
#include <initializer_list>
#include <memory>
#include <optional>
#include <string>
#include <string_view>
#include <utility>
#include <vector>

#include "AST/Decl.hpp"
#include "AST/Expr.hpp"
#include "AST/Stmt.hpp"
#include "AST/Type.hpp"
#include "Diagnostics/Diagnostic.hpp"
#include "Diagnostics/DiagnosticBuilder.hpp"
#include "Diagnostics/DiagnosticManager.hpp"
#include "Lexer/Token.hpp"
#include "Lexer/TokenKind.hpp"
#include "SrcManager/SrcLocation.hpp"

namespace phi {

//===----------------------------------------------------------------------===//
// Parser - Recursive descent parser for the Phi programming language
//===----------------------------------------------------------------------===//

/**
 * @brief Recursive descent parser for the Phi programming language
 *
 * Converts a sequence of tokens into an abstract syntax tree (AST) by
 * implementing grammar production rules through recursive methods. Features:
 * - Comprehensive error reporting with precise location information
 * - Robust error recovery through token synchronization points
 * - Pratt parsing for expression precedence handling
 * - Detailed context-aware error messages
 */
class Parser {
public:
  //===--------------------------------------------------------------------===//
  // Constructors & Destructors
  //===--------------------------------------------------------------------===//

  /**
   * @brief Constructs a parser instance
   *
   * @param src The complete source code being parsed
   * @param path The file path of the source code
   * @param tokens The token sequence generated by the lexer
   * @param diagnostic_manager The diagnostic reporting system
   */
  Parser(const std::string_view Src, const std::string_view Path,
         std::vector<Token> &Tokens,
         std::shared_ptr<DiagnosticManager> DiagnosticManager);

  //===--------------------------------------------------------------------===//
  // Main Entry Point
  //===--------------------------------------------------------------------===//

  /**
   * @brief Main entry point for parsing
   *
   * @return std::pair<std::vector<std::unique_ptr<FunDecl>>, bool>
   *         First element: Vector of parsed function declarations
   *         Second element: true if parsing completed without errors,
   *                        false if errors occurred
   */
  std::vector<std::unique_ptr<Decl>> parse();

private:
  //===--------------------------------------------------------------------===//
  // Parser State
  //===--------------------------------------------------------------------===//

  std::string Path;
  std::vector<std::string_view> Lines;
  std::vector<Token> &Tokens;
  std::vector<Token>::iterator TokenIt;
  std::vector<std::unique_ptr<Decl>> Ast;
  std::shared_ptr<DiagnosticManager> DiagnosticsMan;

  bool NoStructInit = false;

  //===--------------------------------------------------------------------===//
  // Token Navigation Utilities
  //===--------------------------------------------------------------------===//

  [[nodiscard]] bool atEOF() const;
  [[nodiscard]] Token peekToken() const;
  [[nodiscard]] Token peekToken(int Offset) const;

  Token advanceToken();
  bool expectToken(TokenKind Expected, const std::string &Context = "");
  bool matchToken(TokenKind Kind);

  //===--------------------------------------------------------------------===//
  // Diagnostic Reporting
  //===--------------------------------------------------------------------===//

  void emitError(Diagnostic &&Diag) { DiagnosticsMan->emit(Diag); }
  void emitWarning(Diagnostic &&Diag) const { DiagnosticsMan->emit(Diag); }
  void emitExpectedFoundError(const std::string &Expected,
                              const Token &FoundToken);
  void
  emitUnexpectedTokenError(const Token &Token,
                           const std::vector<std::string> &ExpectedTokens = {});
  void emitUnclosedDelimiterError(const Token &OpeningToken,
                                  const std::string &ExpectedClosing);

  //===--------------------------------------------------------------------===//
  // Error Recovery
  //===--------------------------------------------------------------------===//

  bool SyncToTopLvl();
  bool SyncToStmt();
  bool syncTo(const std::initializer_list<TokenKind> TargetTokens);
  bool syncTo(const TokenKind TargetToken);

  //===--------------------------------------------------------------------===//
  // Enum Parsing
  //===--------------------------------------------------------------------===//

  std::optional<VariantDecl> parseVariantDecl();
  std::unique_ptr<EnumDecl> parseEnumDecl();

  //===--------------------------------------------------------------------===//
  // Struct Parsing
  //===--------------------------------------------------------------------===//

  std::unique_ptr<StructDecl> parseStructDecl();
  std::unique_ptr<FieldDecl> parseFieldDecl(uint32_t FieldIndex);
  std::optional<MethodDecl> parseMethodDecl(std::string ParentName,
                                            SrcLocation ParentLoc);

  //===--------------------------------------------------------------------===//
  // Type System Parsing
  //===--------------------------------------------------------------------===//

  std::optional<Type> parseType();

  //===--------------------------------------------------------------------===//
  // Function Declaration Parsing
  //===--------------------------------------------------------------------===//

  std::unique_ptr<FunDecl> parseFunDecl();
  std::unique_ptr<ParamDecl> parseParamDecl();
  std::unique_ptr<Block> parseBlock();

  //===--------------------------------------------------------------------===//
  // Statement Parsing
  //===--------------------------------------------------------------------===//

  std::unique_ptr<Stmt> parseStmt();
  std::unique_ptr<ReturnStmt> parseReturnStmt();
  std::unique_ptr<DeferStmt> parseDeferStmt();
  std::unique_ptr<IfStmt> parseIfStmt();
  std::unique_ptr<WhileStmt> parseWhileStmt();
  std::unique_ptr<ForStmt> parseForStmt();
  std::unique_ptr<DeclStmt> parseDeclStmt();
  std::unique_ptr<BreakStmt> parseBreakStmt();
  std::unique_ptr<ContinueStmt> parseContinueStmt();

  //===--------------------------------------------------------------------===//
  // Expression Parsing
  //===--------------------------------------------------------------------===//

  std::unique_ptr<Expr> parseExpr();
  std::unique_ptr<Expr> pratt(int MinBp,
                              const std::vector<TokenKind> &Terminators);

  std::unique_ptr<Expr> parseNud(const Token &Tok);
  std::unique_ptr<Expr> parsePrefixUnaryOp(const Token &Tok);
  std::unique_ptr<Expr> parsePrimitiveLiteral(const Token &Tok);
  std::unique_ptr<Expr> parseGroupingOrTupleLiteral();

  std::unique_ptr<Expr> parsePostfix(const Token &Op,
                                     std::unique_ptr<Expr> Expr);
  std::unique_ptr<Expr> parseInfix(const Token &Op, std::unique_ptr<Expr> Expr,
                                   int RBp);
  std::unique_ptr<FunCallExpr> parseFunCall(std::unique_ptr<Expr> Callee);
  std::unique_ptr<StructLiteral> parseStructLiteral(std::unique_ptr<Expr> expr);
  std::unique_ptr<FieldInitExpr> parseFieldInit();

  //===--------------------------------------------------------------------===//
  // Parsing Utilities
  //===--------------------------------------------------------------------===//

  struct TypedBinding {
    SrcLocation Loc;
    std::string Name;
    Type Type;
  };
  std::optional<TypedBinding> parseTypedBinding();

  /**
   * @brief Generic list parsing template
   *
   * Parses comma-separated lists enclosed by delimiters (e.g., parameters,
   * arguments)
   *
   * @tparam T Type of elements in the list
   * @tparam F Parser method type for individual elements
   * @param opening Opening delimiter token type
   * @param closing Closing delimiter token type
   * @param fun Member function pointer to element parser
   * @param context Description of list context for error messages
   * @return std::vector<std::unique_ptr<T>>
   *         Vector of parsed elements (empty on failure)
   *         Errors are emitted to DiagnosticManager
   */
  template <typename T, typename F>
  std::optional<std::vector<std::unique_ptr<T>>>
  parseList(const TokenKind Opening, const TokenKind Closing, F Fun,
            const std::string &Context = "list") {
    // Verify opening delimiter
    const Token OpeningToken = peekToken();
    if (OpeningToken.getKind() != Opening) {
      emitExpectedFoundError(tyToStr(Opening), OpeningToken);
      return std::nullopt;
    }
    advanceToken();

    // Parse list elements
    std::vector<std::unique_ptr<T>> Content;
    while (!atEOF() && peekToken().getKind() != Closing) {
      auto Result = std::invoke(Fun, this);
      if (Result) {
        Content.push_back(std::move(Result));
      } else {
        // Recover by syncing to comma or closing delimiter
        syncTo({Closing, TokenKind::Comma});
      }

      // Check for closing delimiter before comma
      if (peekToken().getKind() == Closing) {
        break;
      }

      // Handle comma separator
      if (peekToken().getKind() == TokenKind::Comma) {
        advanceToken();
      } else {
        emitError(
            error("missing comma in " + Context)
                .with_primary_label(spanFromToken(peekToken()),
                                    "expected `,` here")
                .with_help("separate " + Context + " elements with commas")
                .build());
        return std::nullopt;
      }
    }

    // Verify closing delimiter
    if (atEOF() || peekToken().getKind() != Closing) {
      emitUnclosedDelimiterError(OpeningToken, tyToStr(Closing));
      return std::nullopt;
    }

    advanceToken(); // Consume closing delimiter
    return Content;
  }

  template <typename T, typename F>
  std::optional<std::vector<T>>
  parseValueList(const TokenKind Opening, const TokenKind Closing, F Fun,
                 const std::string &Context = "list") {
    // Verify opening delimiter
    const Token OpeningToken = peekToken();
    if (OpeningToken.getKind() != Opening) {
      emitExpectedFoundError(tyToStr(Opening), OpeningToken);
      return std::nullopt;
    }
    advanceToken();

    // Parse list elements
    std::vector<T> Content;
    while (!atEOF() && peekToken().getKind() != Closing) {
      auto Res = std::invoke(Fun, this);
      if (Res) {
        Content.push_back(std::move(*Res));
      } else {
        // Recover by syncing to comma or closing delimiter
        syncTo({Closing, TokenKind::Comma});
      }

      // Check for closing delimiter before comma
      if (peekToken().getKind() == Closing) {
        break;
      }

      // Handle comma separator
      if (peekToken().getKind() == TokenKind::Comma) {
        advanceToken();
      } else {
        emitError(
            error("missing comma in " + Context)
                .with_primary_label(spanFromToken(peekToken()),
                                    "expected `,` here")
                .with_help("separate " + Context + " elements with commas")
                .build());
        return std::nullopt;
      }
    }

    // Verify closing delimiter
    if (atEOF() || peekToken().getKind() != Closing) {
      emitUnclosedDelimiterError(OpeningToken, tyToStr(Closing));
      return std::nullopt;
    }

    advanceToken(); // Consume closing delimiter
    return Content;
  }
};

} // namespace phi

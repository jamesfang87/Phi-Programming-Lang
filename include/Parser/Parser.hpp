#pragma once

#include <memory>
#include <optional>
#include <string>
#include <string_view>
#include <utility>
#include <vector>

#include "AST/Decl.hpp"
#include "AST/Expr.hpp"
#include "AST/Stmt.hpp"
#include "AST/Type.hpp"
#include "Diagnostics/Diagnostic.hpp"
#include "Diagnostics/DiagnosticBuilder.hpp"
#include "Diagnostics/DiagnosticManager.hpp"
#include "Lexer/Token.hpp"
#include "Lexer/TokenType.hpp"

namespace phi {

/**
 * @brief Recursive descent parser for the Phi programming language
 *
 * Converts a sequence of tokens into an abstract syntax tree (AST) by
 * implementing grammar production rules through recursive methods. Features:
 * - Comprehensive error reporting with precise location information
 * - Robust error recovery through token synchronization points
 * - Pratt parsing for expression precedence handling
 * - Detailed context-aware error messages
 */
class Parser {
public:
    /**
     * @brief Constructs a parser instance
     *
     * @param src The complete source code being parsed
     * @param path The file path of the source code
     * @param tokens The token sequence generated by the lexer
     * @param diagnostic_manager The diagnostic reporting system
     */
    Parser(const std::string_view src,
           const std::string_view path,
           std::vector<Token>& tokens,
           std::shared_ptr<DiagnosticManager> diagnostic_manager);

    /**
     * @brief Main entry point for parsing
     *
     * @return std::pair<std::vector<std::unique_ptr<FunDecl>>, bool>
     *         First element: Vector of parsed function declarations
     *         Second element: true if parsing completed without errors,
     *                        false if errors occurred
     */
    std::pair<std::vector<std::unique_ptr<FunDecl>>, bool> parse();

private:
    // PARSER STATE
    std::string path;                                ///< Source file path for diagnostics
    std::vector<std::string_view> lines;             ///< Cached source lines for error context
    std::vector<Token>& tokens;                      ///< Reference to token sequence
    std::vector<Token>::iterator token_it;           ///< Current position in token sequence
    std::vector<std::unique_ptr<FunDecl>> functions; ///< Collected function declarations
    std::shared_ptr<DiagnosticManager> diagnostic_manager; ///< Diagnostic reporting system

    // TOKEN NAVIGATION UTILITIES
    /// Checks if parser has reached end of token stream
    [[nodiscard]] bool at_eof() const;

    /// Returns the current token without advancing
    [[nodiscard]] Token peek_token() const;

    /// Advances to next token and returns the previous one
    Token advance_token();

    /**
     * @brief Verifies current token matches expected type
     *
     * @param expected_type The expected token type
     * @param context Context description for error messages
     * @return true if token matches, false otherwise
     *
     * @note Automatically generates error if token doesn't match
     */
    bool expect_token(TokenType expected_type, const std::string& context = "");

    /**
     * @brief Conditionally consumes token if it matches
     *
     * @param type Token type to match
     * @return true if token matched and consumed, false otherwise
     */
    bool match_token(TokenType type);

    // DIAGNOSTIC REPORTING
    void emit_error(Diagnostic&& diagnostic) { diagnostic_manager->emit(diagnostic); }
    void emit_warning(Diagnostic&& diagnostic) const { diagnostic_manager->emit(diagnostic); }

    /**
     * @brief Reports "expected X but found Y" error
     *
     * @param expected String description of expected token
     * @param found_token The actual token encountered
     */
    void emit_expected_found_error(const std::string& expected, const Token& found_token);

    /**
     * @brief Reports unexpected token error
     *
     * @param token The unexpected token
     * @param expected_tokens List of expected token descriptions
     */
    void emit_unexpected_token_error(const Token& token,
                                     const std::vector<std::string>& expected_tokens = {});

    /**
     * @brief Reports unclosed delimiter error
     *
     * @param opening_token The opening delimiter token
     * @param expected_closing String representation of expected closing delimiter
     */
    void emit_unclosed_delimiter_error(const Token& opening_token,
                                       const std::string& expected_closing);

    // ERROR RECOVERY
    /**
     * @brief Synchronizes parser state to next safe point
     *
     * Attempts to recover from errors by skipping tokens until reaching a
     * token that likely begins a new construct (statement or declaration).
     *
     * @return true if synchronized successfully, false if reached EOF
     */
    bool sync_to_top_lvl();

    /**
     * @brief Synchronizes parser state to next safe point
     *
     * Attempts to recover from errors by skipping tokens until reaching a
     * token that likely begins a new construct (statement or declaration).
     *
     * @return true if synchronized successfully, false if reached EOF
     */
    bool sync_to_stmt();

    /**
     * @brief Synchronizes to one of specified token types
     *
     * @param target_tokens Set of tokens to synchronize to
     * @return true if found synchronization token, false if reached EOF
     */
    bool sync_to(const std::initializer_list<TokenType> target_tokens);

    /**
     * @brief Synchronizes to specific token type
     *
     * @param target_token Token type to synchronize to
     * @return true if found target token, false if reached EOF
     */
    bool sync_to(const TokenType target_token);

    // TYPE SYSTEM PARSING
    /**
     * @brief Parses type annotations
     *
     * @return std::optional<Type>
     *         Valid type if successful, std::nullopt on failure
     *         Errors are reported through the DiagnosticManager
     */
    std::optional<Type> parse_type();

    // FUNCTION DECLARATION PARSING
    std::unique_ptr<FunDecl> parse_function_decl();
    std::unique_ptr<ParamDecl> parse_param_decl();
    std::unique_ptr<Block> parse_block();

    // STATEMENT PARSING
    std::unique_ptr<Stmt> parse_stmt();
    std::unique_ptr<ReturnStmt> parse_return_stmt();
    std::unique_ptr<IfStmt> parse_if_stmt();
    std::unique_ptr<WhileStmt> parse_while_stmt();
    std::unique_ptr<ForStmt> parse_for_stmt();
    std::unique_ptr<LetStmt> parse_let_stmt();

    // EXPRESSION PARSING
    std::unique_ptr<Expr> parse_expr();

    /**
     * @brief Pratt parser implementation for expressions
     *
     * @param min_bp Minimum binding power for current context
     * @return std::unique_ptr<Expr>
     *         Parsed expression or nullptr on failure
     *         Errors are emitted to DiagnosticManager
     */
    std::unique_ptr<Expr> pratt(int min_bp);

    std::unique_ptr<Expr> parse_prefix(const Token& tok);

    /**
     * @brief Parses postfix operators for an expression
     *
     * @param expr The expression to apply postfix operators to
     * @return std::unique_ptr<Expr>
     *         Expression with postfix operators applied or nullptr on failure
     *         Errors are emitted to DiagnosticManager
     */
    std::unique_ptr<Expr> parse_postfix(std::unique_ptr<Expr> expr);

    /**
     * @brief Parses function call expressions
     *
     * @param callee The expression being called
     * @return std::unique_ptr<FunCallExpr>
     *         Function call expression or nullptr on failure
     *         Errors are emitted to DiagnosticManager
     */
    std::unique_ptr<FunCallExpr> parse_fun_call(std::unique_ptr<Expr> callee);

    // PARSING UTILITIES
    std::optional<std::pair<std::string, Type>> parse_typed_binding();

    /**
     * @brief Generic list parsing template
     *
     * Parses comma-separated lists enclosed by delimiters (e.g., parameters, arguments)
     *
     * @tparam T Type of elements in the list
     * @tparam F Parser method type for individual elements
     * @param opening Opening delimiter token type
     * @param closing Closing delimiter token type
     * @param fun Member function pointer to element parser
     * @param context Description of list context for error messages
     * @return std::vector<std::unique_ptr<T>>
     *         Vector of parsed elements (empty on failure)
     *         Errors are emitted to DiagnosticManager
     */
    template <typename T, typename F>
    std::optional<std::vector<std::unique_ptr<T>>> parse_list(const TokenType opening,
                                                              const TokenType closing,
                                                              F fun,
                                                              const std::string& context = "list") {
        // Verify opening delimiter
        const Token opening_token = advance_token();
        if (opening_token.get_type() != opening) {
            emit_expected_found_error(type_to_string(opening), peek_token());
            return std::nullopt;
        }

        // Parse list elements
        std::vector<std::unique_ptr<T>> content;
        while (!at_eof() && peek_token().get_type() != closing) {
            auto result = (this->*fun)();
            if (!result) {
                // Recover by syncing to comma or closing delimiter
                sync_to({closing, TokenType::tok_comma});
                continue;
            }
            content.push_back(std::move(result));

            // Check for closing delimiter before comma
            if (peek_token().get_type() == closing) {
                break;
            }

            // Handle comma separator
            if (peek_token().get_type() == TokenType::tok_comma) {
                advance_token();
            } else {
                emit_error(
                    error("missing comma in " + context)
                        .with_primary_label(span_from_token(peek_token()), "expected `,` here")
                        .with_help("separate " + context + " elements with commas")
                        .build());
                return std::nullopt;
            }
        }

        // Verify closing delimiter
        if (at_eof() || peek_token().get_type() != closing) {
            emit_unclosed_delimiter_error(opening_token, type_to_string(closing));
            return std::nullopt;
        }

        advance_token(); // Consume closing delimiter
        return content;
    }
};

} // namespace phi

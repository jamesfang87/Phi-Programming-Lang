#include "Sema/TypeInference/Infer.hpp"

#include <cassert>
#include <optional>

#include "AST/Decl.hpp"
#include "Sema/TypeInference/Algorithms.hpp"
#include "Sema/TypeInference/Types/Monotype.hpp"
#include "Sema/TypeInference/Types/Polytype.hpp"

namespace phi {

// ---------------- declarations ----------------
void TypeInferencer::inferDecl(Decl &D) {
  if (auto *V = dynamic_cast<VarDecl *>(&D))
    inferVarDecl(*V);
  else if (auto *F = dynamic_cast<FunDecl *>(&D))
    inferFunDecl(*F);
  else {
    // StructDecl, FieldDecl, MethodDecl not handled here.
  }
}

// VarDecl: infer initializer, unify with annotation (if present), then bind.
// IMPORTANT: only generalize if this VarDecl was predeclared (i.e. top-level).
// Local variables must be kept monomorphic so that later unifications (e.g.
// from passing them to functions) update the same monotype instance.
void TypeInferencer::inferVarDecl(VarDecl &D) {
  const std::optional<Polytype> P = Env.lookup(&D);
  const bool TopLevel = static_cast<bool>(P);

  // Starting monotype: instantiate predeclared scheme, or create fresh var for
  // local.
  Monotype VarType =
      TopLevel ? instantiate(*P, Factory) : Monotype::makeVar(Factory.fresh());

  Substitution Subst;
  if (D.hasInit()) {
    auto [InitSubst, InitType] = visit(D.getInit());
    Subst = std::move(InitSubst);
    VarType = Subst.apply(VarType);
    unifyInto(Subst, VarType, InitType);
  }

  if (D.hasType()) {
    const auto DeclaredAs = D.getType().toMonotype();
    unifyInto(Subst, VarType, DeclaredAs);
    VarType = Subst.apply(DeclaredAs);

  } else {
    VarType = Subst.apply(VarType);
  }

  // Propagate substitutions globally (so subsequent lookups see effects).
  recordSubst(Subst);

  // Bind into the environment:
  if (TopLevel) {
    // Top-level/letrec: generalize as
    Env.bind(&D, generalize(Env, VarType));
  } else {
    // Local variable: bind a monomorphic scheme (no quantification).
    // This ensures the same Monotype instance stays associated with the VarDecl
    // for the remainder of the function, so later unifications update it.
    Env.bind(&D, Polytype{{}, VarType});
  }

  // Side-table annotate (will be finalized later)
  annotate(D, VarType);
}

// FunDecl: functions are looked up by name; param/return types MUST be
// annotated by the user (we only verify consistency). We bind params
// temporarily for body inference and discard them afterwards.
void TypeInferencer::inferFunDecl(FunDecl &D) {
  std::optional<Monotype> FunType;

  // Lookup by name
  if (auto Polytype = Env.lookup(D.getId())) {
    FunType = instantiate(*Polytype, Factory);
  } else {
    std::vector<Monotype> Params;
    Params.reserve(D.getParams().size());
    for (auto &Param : D.getParams()) {
      assert(Param->hasType());
      Params.push_back(Param->getType().toMonotype());
    }

    auto Ret = D.getReturnTy().toMonotype();
    FunType = Monotype::makeFun(std::move(Params), Ret);
  }

  if (!FunType->isFun())
    throw std::runtime_error("internal: function expected a function monotype");

  // Save environment (we will restore)
  auto SavedEnv = Env;

  // Bind parameters (use user-declared types) for body inference
  for (auto &Param : D.getParams()) {
    assert(Param->hasType());

    auto T = Param->getType().toMonotype();
    Env.bind(Param.get(), Polytype{{}, T});
    // record param monotype too so we can finalize param annotations if desired
    ValDeclMonos[Param.get()] = T;
  }

  // Use declared return type as expected for body
  auto DeclaredRet = D.getReturnTy().toMonotype();
  CurFunRetType.push_back(DeclaredRet);

  // Infer body
  auto [BodySubst, _] = inferBlock(D.getBody());

  // Propagate body substitution globally (important so call-sites see effects)
  recordSubst(BodySubst);

  // Apply substitution to function type
  FunType = BodySubst.apply(*FunType);

  CurFunRetType.pop_back();

  // Verify declared param/return types match inferred FnT (unify to find
  // errors)
  // Record substitutions generated by those checks too
  for (size_t i = 0; i < D.getParams().size(); ++i) {
    ParamDecl *P = D.getParams()[i].get();
    auto DeclParamTy = P->getType().toMonotype();
    unifyInto(BodySubst, DeclParamTy, FunType->asFun().Params[i]);
  }
  auto DeclaredRetType = D.getReturnTy().toMonotype();
  unifyInto(BodySubst, DeclaredRetType, *FunType->asFun().Ret);
  recordSubst(BodySubst);

  // Re-generalize in outer environment and rebind function name
  SavedEnv.bind(D.getId(), generalize(SavedEnv, *FunType));

  // Optionally record function monotype in DeclMonos (we don't mutate AST
  // function signature)
  FunDeclMonos[&D] = *FunType;

  // Restore outer environment
  Env = std::move(SavedEnv);
}

} // namespace phi

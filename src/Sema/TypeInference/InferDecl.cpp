#include "Sema/TypeInference/Infer.hpp"

#include <cassert>
#include <optional>

#include "AST/Decl.hpp"
#include "Sema/TypeInference/Algorithms.hpp"
#include "Sema/TypeInference/Types/Monotype.hpp"
#include "Sema/TypeInference/Types/Polytype.hpp"

namespace phi {

// ---------------- declarations ----------------
void TypeInferencer::visit(Decl &D) { D.accept(*this); }

// VarDecl: infer initializer, unify with annotation (if present), then bind.
// IMPORTANT: only generalize if this VarDecl was predeclared (i.e. top-level).
// Local variables must be kept monomorphic so that later unifications (e.g.
// from passing them to functions) update the same monotype instance.
void TypeInferencer::visit(VarDecl &D) {
  Monotype VarType = Monotype::makeVar(Factory.fresh());

  Substitution Subst;
  if (D.hasInit()) {
    auto [InitSubst, InitType] = visit(D.getInit());
    Subst = std::move(InitSubst);
    VarType = Subst.apply(VarType);
    unifyInto(Subst, VarType, InitType);
  }

  if (D.hasType()) {
    const auto DeclaredAs = D.getType().toMonotype();
    unifyInto(Subst, VarType, DeclaredAs);
    VarType = Subst.apply(DeclaredAs);
  } else {
    VarType = Subst.apply(VarType);
  }

  // Propagate substitutions globally (so subsequent lookups see effects).
  recordSubst(Subst);

  // Local variable: bind a monomorphic scheme (no quantification).
  // This ensures the same Monotype instance stays associated with the VarDecl
  // for the remainder of the function, so later unifications update it.
  Env.bind(&D, Polytype{{}, VarType});

  // Side-table annotate (will be finalized later)
  annotate(D, VarType);
}

// FunDecl: functions are looked up by name; param/return types MUST be
// annotated by the user (we only verify consistency). We bind params
// temporarily for body inference and discard them afterwards.
void TypeInferencer::visit(FunDecl &D) {
  std::optional<Monotype> FunType;

  // Lookup by name
  if (auto Polytype = Env.lookup(D.getId())) {
    FunType = instantiate(*Polytype, Factory);
  } else {
    std::vector<Monotype> Params;
    Params.reserve(D.getParams().size());
    for (auto &Param : D.getParams()) {
      assert(Param->hasType());
      Params.push_back(Param->getType().toMonotype());
    }

    auto Ret = D.getReturnTy().toMonotype();
    FunType = Monotype::makeFun(std::move(Params), Ret);
  }

  assert(FunType->isFun());

  // Save environment (we will restore)
  auto SavedEnv = Env;

  // Bind parameters (use user-declared types) for body inference
  for (auto &Param : D.getParams()) {
    assert(Param->hasType());

    auto T = Param->getType().toMonotype();
    Env.bind(Param.get(), Polytype{{}, T});
    // record param monotype too so we can finalize param annotations if desired
    ValDeclMonos[Param.get()] = T;
  }

  // Use declared return type as expected for body
  auto DeclaredRet = D.getReturnTy().toMonotype();
  CurFunRetType.push_back(DeclaredRet);

  // Infer body
  auto [BodySubst, _] = inferBlock(D.getBody());

  // Propagate body substitution globally (important so call-sites see effects)
  recordSubst(BodySubst);

  // Apply substitution to function type
  FunType = BodySubst.apply(*FunType);

  CurFunRetType.pop_back();

  // Verify declared param/return types match inferred FnT (unify to find
  // errors)
  // Record substitutions generated by those checks too
  for (size_t I = 0; I < D.getParams().size(); ++I) {
    ParamDecl *P = D.getParams()[I].get();
    auto DeclParamTy = P->getType().toMonotype();
    unifyInto(BodySubst, DeclParamTy, FunType->asFun().Params[I]);
  }
  auto DeclaredRetType = D.getReturnTy().toMonotype();
  unifyInto(BodySubst, DeclaredRetType, *FunType->asFun().Ret);
  recordSubst(BodySubst);

  // Re-generalize in outer environment and rebind function name
  SavedEnv.bind(D.getId(), generalize(SavedEnv, *FunType));

  // Optionally record function monotype in DeclMonos (we don't mutate AST
  // function signature)
  FunDeclMonos[&D] = *FunType;

  // Restore outer environment
  Env = std::move(SavedEnv);
}

void TypeInferencer::visit(StructDecl &D) {
  // Create struct monotype and bind the struct name (so fields/methods can
  // reference it)
  Monotype StructMono = Monotype::makeVar(Factory.fresh());
  Env.bind(D.getId(), Polytype{{}, StructMono});

  // Bind fields into Env and annotate
  for (auto &Fptr : D.getFields()) {
    FieldDecl *FD = Fptr.get();
    assert(FD->hasType() && "struct fields must have type annotations");
    Monotype FT = FD->getType().toMonotype();
    Env.bind(FD, Polytype{{}, FT}); // <-- bind field decl into Env
    ValDeclMonos[FD] = FT;
    annotate(*FD, FT);
  }

  // Methods: same approach as functions but prepend self (StructMono).
  for (auto &Mptr : D.getMethods()) {
    MethodDecl *M = &Mptr;

    // Build method monotype
    std::vector<Monotype> ParamMonos;
    ParamMonos.reserve(1 + M->getParams().size());
    ParamMonos.push_back(StructMono); // self
    for (auto &P : M->getParams())
      ParamMonos.push_back(P->getType().toMonotype());
    Monotype RetMono = M->getReturnTy().toMonotype();
    Monotype MethodMono = Monotype::makeFun(std::move(ParamMonos), RetMono);

    auto SavedEnv = Env;

    // Bind AST-visible params (do not bind 'self' as an AST param)
    for (auto &P : M->getParams()) {
      Monotype PT = P->getType().toMonotype();
      Env.bind(P.get(), Polytype{{}, PT});
      ValDeclMonos[P.get()] = PT;
    }

    CurFunRetType.push_back(RetMono);
    auto [BodySubst, _] = inferBlock(M->getBody());
    recordSubst(BodySubst);
    MethodMono = BodySubst.apply(MethodMono);
    CurFunRetType.pop_back();

    // Unify declared param/return types with inferred
    auto &Mf = MethodMono.asFun();
    for (size_t I = 0; I < M->getParams().size(); ++I) {
      ParamDecl *P = M->getParams()[I].get();
      Monotype DeclParamTy = P->getType().toMonotype();
      unifyInto(BodySubst, DeclParamTy, Mf.Params[I + 1]); // skip self
    }
    unifyInto(BodySubst, RetMono, *Mf.Ret);
    recordSubst(BodySubst);

    // Re-generalize and bind method under dotted name
    std::string Qualified = D.getId() + "." + M->getId();
    SavedEnv.bind(Qualified, generalize(SavedEnv, MethodMono));
    FunDeclMonos[M] = MethodMono;

    Env = std::move(SavedEnv);
  }
}

void TypeInferencer::visit(EnumDecl &D) {}

} // namespace phi

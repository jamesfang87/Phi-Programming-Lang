#include "AST/Decl.hpp"
#include "Sema/HMTI/Algorithms.hpp"
#include "Sema/HMTI/Infer.hpp"
#include "Sema/HMTI/Types/Monotype.hpp"
#include <cassert>
#include <optional>

namespace phi {

// ---------------- declarations ----------------
void TypeInferencer::inferDecl(Decl &D) {
  if (auto *V = dynamic_cast<VarDecl *>(&D))
    inferVarDecl(*V);
  else if (auto *F = dynamic_cast<FunDecl *>(&D))
    inferFunDecl(*F);
  else {
    // StructDecl, FieldDecl, MethodDecl not handled here.
  }
}

// VarDecl: infer initializer, unify with annotation (if present), then bind.
// IMPORTANT: only generalize if this VarDecl was predeclared (i.e. top-level).
// Local variables must be kept monomorphic so that later unifications (e.g.
// from passing them to functions) update the same monotype instance.
void TypeInferencer::inferVarDecl(VarDecl &D) {
  // Was this predeclared (top-level)? If so, Env_.lookup(&D) returns a Scheme.
  auto ScOpt = Env.lookup(&D);
  const bool WasPredeclared = static_cast<bool>(ScOpt);

  // Starting monotype: instantiate predeclared scheme, or create fresh var for
  // local.
  Monotype VarTy = WasPredeclared ? instantiate(*ScOpt, Factory)
                                  : Monotype::makeVar(Factory.fresh());

  Substitution S;
  if (D.hasInit()) {
    auto [Si, Ti] = visit(D.getInit());
    S = std::move(Si);
    VarTy = S.apply(VarTy);
    unifyInto(S, VarTy, Ti);
  }

  if (D.hasType()) {
    auto Ann = D.getType().toMonotype();
    unifyInto(S, VarTy, Ann);
    VarTy = S.apply(Ann);
  } else {
    VarTy = S.apply(VarTy);
  }

  // Propagate substitutions globally (so subsequent lookups see effects).
  recordSubst(S);

  // Bind into the environment:
  if (WasPredeclared) {
    // Top-level/letrec: generalize as before.
    auto Sc = generalize(Env, VarTy);
    Env.bind(&D, Sc);
  } else {
    // Local variable: bind a monomorphic scheme (no quantification).
    // This ensures the same Monotype instance stays associated with the VarDecl
    // for the remainder of the function, so later unifications update it.
    Env.bind(&D, Polytype{{}, VarTy});
  }

  // Side-table annotate (will be finalized later)
  annotate(D, VarTy);
}

// FunDecl: functions are looked up by name; param/return types MUST be
// annotated by the user (we only verify consistency). We bind params
// temporarily for body inference and discard them afterwards.
void TypeInferencer::inferFunDecl(FunDecl &D) {
  std::optional<Monotype> FunType;

  // Lookup by name
  if (auto Polytype = Env.lookup(D.getId())) {
    FunType = instantiate(*Polytype, Factory);
  } else {
    std::vector<Monotype> Params;
    Params.reserve(D.getParams().size());
    for (auto &Param : D.getParams()) {
      assert(Param->hasType());
      Params.push_back(Param->getType().toMonotype());
    }

    auto Ret = D.getReturnTy().toMonotype();
    FunType = Monotype::makeFun(std::move(Params), Ret);
  }

  if (!FunType->isFun())
    throw std::runtime_error("internal: function expected a function monotype");

  // Save environment (we will restore)
  auto SavedEnv = Env;

  // Bind parameters (use user-declared types) for body inference
  for (auto &Param : D.getParams()) {
    assert(Param->hasType());

    auto T = Param->getType().toMonotype();
    Env.bind(Param.get(), Polytype{{}, T});
    // record param monotype too so we can finalize param annotations if desired
    ValDeclMonos[Param.get()] = T;
  }

  // Use declared return type as expected for body
  auto DeclaredRet = D.getReturnTy().toMonotype();
  CurrentFnReturnTy.push_back(DeclaredRet);

  // Infer body
  auto [SBody, _] = inferBlock(D.getBody());

  // Propagate body substitution globally (important so call-sites see effects)
  recordSubst(SBody);

  // Apply substitution to function type
  FunType = SBody.apply(*FunType);

  CurrentFnReturnTy.pop_back();

  // Verify declared param/return types match inferred FnT (unify to find
  // errors)
  try {
    for (size_t i = 0; i < D.getParams().size(); ++i) {
      ParamDecl *P = D.getParams()[i].get();
      auto DeclParamTy = P->getType().toMonotype();
      unifyInto(SBody, DeclParamTy, FunType->asFun().Params[i]);
    }
    auto DeclRetTy = D.getReturnTy().toMonotype();
    unifyInto(SBody, DeclRetTy, *FunType->asFun().Ret);
  } catch (const UnifyError &E) {
    throw std::runtime_error(std::string("Type error in function '") +
                             D.getId() + "': " + E.what());
  }

  // Record substitutions generated by those checks too
  recordSubst(SBody);

  // Re-generalize in outer environment and rebind function name
  auto Sc = generalize(SavedEnv, *FunType);
  SavedEnv.bind(D.getId(), Sc);

  // Optionally record function monotype in DeclMonos_ (we don't mutate AST
  // function signature)
  FunDeclMonos[&D] = *FunType;

  // Restore outer environment
  Env = std::move(SavedEnv);
}

} // namespace phi

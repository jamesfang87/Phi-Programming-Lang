#include "Sema/HMTI/Infer.hpp"
#include <print>

namespace phi {

// ---------------- declarations ----------------
void TypeInferencer::inferDecl(Decl &D) {
  if (auto *V = dynamic_cast<VarDecl *>(&D))
    inferVarDecl(*V);
  else if (auto *F = dynamic_cast<FunDecl *>(&D))
    inferFunDecl(*F);
  else {
    // StructDecl, FieldDecl, MethodDecl not handled here.
  }
}

// VarDecl: infer initializer, unify with annotation (if present), then bind.
// IMPORTANT: only generalize if this VarDecl was predeclared (i.e. top-level).
// Local variables must be kept monomorphic so that later unifications (e.g.
// from passing them to functions) update the same monotype instance.
void TypeInferencer::inferVarDecl(VarDecl &D) {
  // Was this predeclared (top-level)? If so, Env_.lookup(&D) returns a Scheme.
  auto ScOpt = Env_.lookup(&D);
  const bool WasPredeclared = static_cast<bool>(ScOpt);

  // Starting monotype: instantiate predeclared scheme, or create fresh var for
  // local.
  std::shared_ptr<Monotype> VarTy = WasPredeclared
                                        ? instantiate(*ScOpt, Factory_)
                                        : Monotype::var(Factory_.fresh());

  Substitution S;
  if (D.hasInit()) {
    auto [Si, Ti] = visit(D.getInit());
    S = std::move(Si);
    VarTy = S.apply(VarTy);
    unifyInto(S, VarTy, Ti);
  }

  if (D.hasType()) {
    auto Ann = fromAstType(D.getType());
    unifyInto(S, VarTy, Ann);
    VarTy = S.apply(Ann);
  } else {
    VarTy = S.apply(VarTy);
  }

  // Propagate substitutions globally (so subsequent lookups see effects).
  recordSubst(S);

  // Bind into the environment:
  if (WasPredeclared) {
    // Top-level/letrec: generalize as before.
    auto Sc = generalize(Env_, VarTy);
    Env_.bind(&D, Sc);
  } else {
    // Local variable: bind a monomorphic scheme (no quantification).
    // This ensures the same Monotype instance stays associated with the VarDecl
    // for the remainder of the function, so later unifications update it.
    Env_.bind(&D, Polytype{{}, VarTy});
    std::println("binded {}", D.getId());
  }

  // Side-table annotate (will be finalized later)
  annotate(D, VarTy);
}

// FunDecl: functions are looked up by name; param/return types MUST be
// annotated by the user (we only verify consistency). We bind params
// temporarily for body inference and discard them afterwards.
void TypeInferencer::inferFunDecl(FunDecl &D) {
  std::shared_ptr<Monotype> FnT;

  // Lookup by name
  if (auto Sc = Env_.lookup(D.getId())) {
    FnT = instantiate(*Sc, Factory_);
  } else {
    // Fallback: build from AST annotations (shouldn't normally happen)
    std::vector<std::shared_ptr<Monotype>> Args;
    Args.reserve(D.getParams().size());
    for (auto &Pup : D.getParams()) {
      ParamDecl *P = Pup.get();
      if (!P->hasType()) {
        throw std::runtime_error("Missing parameter type annotation for '" +
                                 P->getId() + "'");
      }
      Args.push_back(fromAstType(P->getType()));
    }
    auto Ret = fromAstType(D.getReturnTy());
    FnT = Monotype::fun(std::move(Args), Ret);
  }

  if (FnT->tag() != Monotype::Tag::Fun)
    throw std::runtime_error("internal: function expected a function monotype");

  // Save environment (we will restore)
  auto SavedEnv = Env_;

  // Bind parameters (use user-declared types) for body inference
  for (size_t i = 0; i < D.getParams().size(); ++i) {
    ParamDecl *P = D.getParams()[i].get();
    if (!P->hasType()) {
      throw std::runtime_error("Parameter '" + P->getId() +
                               "' must have a type annotation");
    }
    auto Pt = fromAstType(P->getType());
    Env_.bind(P, Polytype{{}, Pt});
    // record param monotype too so we can finalize param annotations if desired
    DeclMonos_[P] = Pt;
  }

  // Use declared return type as expected for body
  auto DeclaredRet = fromAstType(D.getReturnTy());
  CurrentFnReturnTy_.push_back(DeclaredRet);

  // Infer body
  auto [SBody, _] = inferBlock(D.getBody());

  // Propagate body substitution globally (important so call-sites see effects)
  recordSubst(SBody);

  // Apply substitution to function type
  FnT = SBody.apply(FnT);

  CurrentFnReturnTy_.pop_back();

  // Verify declared param/return types match inferred FnT (unify to find
  // errors)
  try {
    for (size_t i = 0; i < D.getParams().size(); ++i) {
      ParamDecl *P = D.getParams()[i].get();
      auto DeclParamTy = fromAstType(P->getType());
      unifyInto(SBody, DeclParamTy, FnT->funArgs()[i]);
    }
    auto DeclRetTy = fromAstType(D.getReturnTy());
    unifyInto(SBody, DeclRetTy, FnT->funRet());
  } catch (const UnifyError &E) {
    throw std::runtime_error(std::string("Type error in function '") +
                             D.getId() + "': " + E.what());
  }

  // Record substitutions generated by those checks too
  recordSubst(SBody);

  // Re-generalize in outer environment and rebind function name
  auto Sc = generalize(SavedEnv, FnT);
  SavedEnv.bind(D.getId(), Sc);

  // Optionally record function monotype in DeclMonos_ (we don't mutate AST
  // function signature)
  FunMonos_[&D] = FnT;

  // Restore outer environment
  Env_ = std::move(SavedEnv);
}

} // namespace phi
